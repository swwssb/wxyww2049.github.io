---
layout: post
date: 2019-01-01
title: CF1178 解题报告
tags: 解题报告,codeforces
---

## A

### 题意

给出一个长度为$n(2 \le n \le 100)$的序列 $a$。选出他的一个子序列$b$。满足下列条件。
>1. 必须选择$a_1$
>2.  对于所有的$2 \le i \le tot$($tot$为所选序列的长度)都有$b_1 \le 2b_i$
>3. $2\sum\limits_{i=1}^{tot}b_i > \sum\limits_{i=1}^na_i$

输出一个符合条件的子序列。

### solve
将所有满足$2a_i \le a_1$的都选上。如果无法达到条件3，说明无解。否则输出。

### code
```cpp
/*
* @Author: wxyww
* @Date:   2019-07-20 23:34:52
* @Last Modified time: 2019-07-21 07:52:08
*/
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<ctime>
using namespace std;
typedef long long ll;
const int N = 110;
ll read() {
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
int SUM,a[N],bz[N],num;
int main() {
	int n = read();
	for(int i = 1;i <= n;++i) 	a[i] = read(),SUM += a[i];
	num = a[1];
	bz[1] = 1;
	int tot = 1;
	for(int i = 2;i <= n;++i) if(a[i] * 2 <= a[1]) ++tot,bz[i] = 1,num += a[i];
 
	if(num * 2 <= SUM) {puts("0");return 0;}
	printf("%d\n",tot);
	for(int i = 1;i <= n;++i) if(bz[i]) printf("%d ",i);
	return 0;
}
```

## B
### 题意

给出一个只含$'v','o'$的字符串。相邻的两个$'v'$可以看做是一个$'w'$，问可以组成$'wow'$的子序列数量。

### solve

正反各做一遍前(后)缀和。然后枚举$'o'$，统计答案即可。

### code
```cpp
/*
* @Author: wxyww
* @Date:   2019-07-21 07:52:15
* @Last Modified time: 2019-07-21 08:08:24
*/
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<ctime>
using namespace std;
typedef long long ll;
const int N = 1000000 + 100;
ll read() {
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
char s[N];
ll sum1[N],sum2[N],ans;

int main() {
	scanf("%s",s + 1);
	int n = strlen(s + 1);
	for(int i = 2;i <= n;++i) {
		sum1[i] = sum1[i - 1];
		if(s[i] == 'v' && s[i - 1] == 'v') sum1[i]++;
	}
	for(int i = n - 1;i >= 1;--i) {
		sum2[i] = sum2[i + 1];
		if(s[i] == 'v' && s[i + 1] == 'v') sum2[i]++;
	}
	for(int i = 1;i <= n;++i) if(s[i] == 'o') ans += sum2[i] * sum1[i];
	cout<<ans;
	return 0;
}
```

## C

### 题意

有一个$w\times h(1\le w,h \le 1000)$的房间。要在里面铺下图所示的瓷砖(长宽均为1)。要求两块相邻的边两边的颜色不同。问方案数。

### solve

