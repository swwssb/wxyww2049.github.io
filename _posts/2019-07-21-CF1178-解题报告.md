---
layout: post
date: 2019-01-01
title: CF1178 解题报告
tags: 解题报告,codeforces
---

## A

### 题意

给出一个长度为$n(2 \le n \le 100)$的序列 $a$。选出他的一个子序列$b$。满足下列条件。
>1. 必须选择$a_1$
>2.  对于所有的$2 \le i \le tot$($tot$为所选序列的长度)都有$b_1 \le 2b_i$
>3. $2\sum\limits_{i=1}^{tot}b_i > \sum\limits_{i=1}^na_i$

输出一个符合条件的子序列。

### solve
将所有满足$2a_i \le a_1$的都选上。如果无法达到条件3，说明无解。否则输出。

### code
```cpp
/*
* @Author: wxyww
* @Date:   2019-07-20 23:34:52
* @Last Modified time: 2019-07-21 07:52:08
*/
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<ctime>
using namespace std;
typedef long long ll;
const int N = 110;
ll read() {
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
int SUM,a[N],bz[N],num;
int main() {
	int n = read();
	for(int i = 1;i <= n;++i) 	a[i] = read(),SUM += a[i];
	num = a[1];
	bz[1] = 1;
	int tot = 1;
	for(int i = 2;i <= n;++i) if(a[i] * 2 <= a[1]) ++tot,bz[i] = 1,num += a[i];
 
	if(num * 2 <= SUM) {puts("0");return 0;}
	printf("%d\n",tot);
	for(int i = 1;i <= n;++i) if(bz[i]) printf("%d ",i);
	return 0;
}
```

## B
### 题意

给出一个只含$'v','o'$的字符串。相邻的两个$'v'$可以看做是一个$'w'$，问可以组成$'wow'$的子序列数量。

### solve

正反各做一遍前(后)缀和。然后枚举$'o'$，统计答案即可。

### code
```cpp
/*
* @Author: wxyww
* @Date:   2019-07-21 07:52:15
* @Last Modified time: 2019-07-21 08:08:24
*/
#include<cstdio>
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<queue>
#include<vector>
#include<ctime>
using namespace std;
typedef long long ll;
const int N = 1000000 + 100;
ll read() {
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') {
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
char s[N];
ll sum1[N],sum2[N],ans;

int main() {
	scanf("%s",s + 1);
	int n = strlen(s + 1);
	for(int i = 2;i <= n;++i) {
		sum1[i] = sum1[i - 1];
		if(s[i] == 'v' && s[i - 1] == 'v') sum1[i]++;
	}
	for(int i = n - 1;i >= 1;--i) {
		sum2[i] = sum2[i + 1];
		if(s[i] == 'v' && s[i + 1] == 'v') sum2[i]++;
	}
	for(int i = 1;i <= n;++i) if(s[i] == 'o') ans += sum2[i] * sum1[i];
	cout<<ans;
	return 0;
}
```

## C

### 题意

有一个$w\times h(1\le w,h \le 1000)$的房间。要在里面铺下图所示的瓷砖(长宽均为1),可以旋转。要求两块相邻的边两边的颜色不同。问方案数。答案对$998244353$取模
![enter description here](https://gitee.com/wxyww/picture/raw/master/小书匠/1563679387575.png)
### solve

当房间相邻的两条边的瓷砖确定了之后。其他的所有瓷砖就也已经确定了。考虑到瓷砖间的相互影响，边缘铺的第一个瓷砖有$4$种方案。其他的均有$2$种方案。所以答案为$4 \times 2^{w + h - 2}=2^{w+h}$

## D

### 题意

构造一张有$n(3\le n\le 1000)$个点的无向图(无重边和自环)。满足:
>1. 边的总数为素数
>2. 所有点的度数均为素数

输出方案

### solve

如果所有点的度数确定了。那么边数就是度数之和的一半。连边就很简单了。

所以考虑怎么确定点的度数。

猜想:必有至少一个$x \in [2n,3n](3 \le n \le 1000)$满足$\frac{x}{2}$为素数。