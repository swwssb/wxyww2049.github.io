---
layout: post
date: 2019-07-29 07:03:56
title: 分治
tags: 分治,学习笔记
---

## 复杂度分析

如果$f(n)=f(\frac{n}{2})+O(n)$则总复杂度为$O(nlogn)$。

>证明:每层总复杂度都是$O(n)$递归$logn$层。

如果$f(n)=f(\frac{n}{2})+O(n^2)$则总复杂度为$O(n^2)$。

>证明:略

## 经典问题

- **所有区间的最大值之和**

找到当前区间$[l,r]$的最大值，设位置为$x$.递归$[l,x-1]$和$[x+1,r]$,统计跨过$x$的区间。因为$x$为当前最大值。所以跨过$x$的区间个数为$x\times (r-x+1)$
可以被卡成$O(n^2)$

- **求所有区间的最大值乘最小值之和**

找中间位置切开，预处理$Ma[L]$表示最大的R使得$max\{L...R\} = max\{L...mid\}$,预处理$Mn[L]$表示最大的R满足$min\{L...R\}=min\{L...mid\}$预处理时，利用$Ma[L] \le Ma[L-1],Mn[L] \le Mn[L-1]$

然后分最小值和最大值分别在左边还是右边四种情况讨论。

- **区间gcd之和**

分为两个区间，考虑跨过mid的区间。

考虑从$[L..mid]$的gcd，共有log种取值。所以可以分为log段。所以枚举左边log段，右边log段，计算gcd。单层复杂度$log^3n$

**正解:**

对于每个$R$都有log段。$a[R][1...logn]$储存以R为右端点，左端点所位于的log段中gcd不同的取值。然后加入新点时，与前面R的log段分别gcd即可。

- **二维平面上最近点对**

hdu1007

首先按照x进行排序。然后进行分治。将所有点分成左右点数目尽量相等的两份。然后分别递归求解。

主要问题在于如何合并。如果暴力枚举左右两边的点计算距离进行合并。复杂度就是$O(n^2)$。考虑如果有个点与中间点(就是切开的点)的横坐标距离超过了d(d为左右两遍递归求解得到的答案)，那么这个点肯定不会对答案产生贡献。所以就不考虑这个点了。然后再考虑剩下点之间的距离。枚举左边的点，如果右边点与当前点y坐标的距离大于d了，那么就不用再枚举其他点了。

## 题目

### 旅行者

luogu3350

>给一张$n \times m$的带正权网格图，有$Q$组询问,每次询问两对点之间的最短路。

**solution**

从中间切开一条线。从a到b经过该线上的点x。那么$dis(a,b) = dis(a,x) + dis(x,b)$，$dis(a,b) = MIN_{x为该线上的点}dis(a,x)+dis(x,b)$

### 连续区间

>给定一个排列$p[1...n]$,求有几个区间$[l,r]$满足$p[l,r]$排序后是连续的。

**solution**

题目转化为$Max(L...R)-Min(L...R) + 1=R-L+1$，然后同经典问题$2$，将最大值最小值在$mid$左右两遍分4种情况讨论。

### Xor最小生成树

>给定$n$个点，第$i$个点的点权是$a[i]$,现在定义边$(i,j)$的权值是$a[i] \otimes a[j]$,求最小生成树。

**solution**

根据最高位分为两部分。左右两边分别递归找出最小生成树。然后要到一条跨越mid的边将这两个最小生成树连起来。

### 区间统计

>给定$a[1...n]$，求有几个区间$[L,R]$满足$a[L] ~ or ~ a[L + 1] ~ or ~ a[L + 1]...a[R] > max(a[L...R])$
$n\le 3 \times 10^5$

**solution**

找到$max(a[L]...a[R])$(设其位置为x)割开，然后左右递归。统计或起来比$a[x]$大的区间。因为这个区间已经包含了x了。所以就是要找左区间一个最靠右的位置l，右区间一个最靠左的位置r。使得$a[l]$和$a[r]$，有一位是$1$，而$a[x]$这一位为$0$

## 二分
### 分数规划

>有n个物品每个物品有$a,b$两个属性。选出一个集合。使得他们$\frac{\sum a}{\sum b}$最大。

**solution**

先二分一个答案。然后把$\sum b$移过去，然后01背包。判断是否可行。

### 小题

>给定n个点$a[1...n]$，要求将他划分成最小的连续区间，使得每个区间的最小圆覆盖的半径$\le S$。

**solution**

枚举一个L，然后计算以这个L为左区间满足条件的R最大可以为多少。直接二分判断复杂度可以被卡成$O(n^2logn)$。所以先倍增计算出一个R的大致范围，然后再在该范围内进行具体二分。总复杂度$O(nlogn)$

## 整体二分

bzoj3110

## CDQ分治

### 三维偏序

>每一个物品有$(a_i,b_i)$两个属性。求最长上升子序列，物品i>物品j当且仅当$i > j且a_i > a_j且b_i > b_j$

**solution**

左右分别递归。然后统计左边对于右边的贡献。

### 矩阵求和

>两种操作，矩阵上单点加一个数，求一个矩阵的和。

**solution**

本质上是求矩阵前缀和。转化为三维偏序。

### 缺1背包问题

>给定 n 个物品的重量W[i]和价值V[i]，Q次询 问，每次询问对除了第i个物品以外的物品 01 背包后重量不超过S的最⼤大价值 n,W,V<=2000.Q<=1000000

**solution**

分治f数组。solve(l,r,f)表示缺[l,r]这个区间，得到的f数组。递归下一层的时候就把另外一边补上。

## 点分治

- **边数$\le L$的链的权值之和**

**solution**

如果一条链没经过重心直接递归下去。

考虑经过重心的情况。以重心将这条链分为两部分。所以就找以重心为根，有多少点对$(x,y)$满足$dep[x] + dep[y] \le L$。枚举x，计算有多少个y满足$dep[y] \le L-dep[x]$，再减去$x,y$在同一子树的情况。 复杂度$O(nlog^2n)$

- **给定一棵树，有 Q 次询问，每次询问离 x 距离 <=L 的点数**

**solution**

将询问离线下来，对于每个点，统计出上层分治对他的询问的贡献，然后再统计出当前树对他的贡献。
