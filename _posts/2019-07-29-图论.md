---
layout: post
date: 2019-07-29 09:28:03
title: 图论
tags: 学习笔记,图论
---

## 最短路变种

bzoj2725

>给定一个带权有向图，Q 次询问，每次询问删掉某条边后 1 到 n 的最短路

**solution**

先选定一条最短路，然后考虑一条不在最短路上的边(u,v,w)。记录下从S到u从哪个点开始离开选定的最短路(记为$S'$)，从v到T的最短路从哪个点开始进入选定的最短路(记为$T'$)，然后当删掉从$S'到T'$之间的边时，都可以用这条最短路代替。用线段树维护，区间修改单点查询。

## 变种2

>给定一个带权有向无环图，Q 次询问，每次询问删掉某个点后1到n的最短路

**solution**

与上面思路类似。统计出每条边对于答案的贡献即可。

## 数环

>给定一张n个点m条边的无向图，求三元环的个数。

**solution**

bzoj3498

按照度数从小到大排序，得到每个点的rank。
然后连一个新的有向图D。对于原图中的边，有rank小的向rank大的连边。新得到的图的边出度之和小于$\sqrt{m}$。然后枚举一个a，将a连出去的点标记一下。然后枚举a连出去的点y，再枚举y连出去的点z，记录有多少个z被标记了。

```cpp
for(a 连向y) res[y] = 1;
for(a = 1 to n) {
for( a向y有连边) 
    for( y向z有连边) 
    ans+=res[z];
```

复杂度为$n\sqrt{n}$

## 数环+

>给定一张n个点m条边的无向图，求四元环的个数。

**solution**

类似于三元环连边。

每两条从x到z的路径可以构成一个四元环。所以统计出已经有多少条路径。然后将新路径与其两两组合。

```cpp
for(x = 1 to n) 
    for(x 向 y连有无向边) //原图中
        for(y 向 z连有边) //新图中
          ans += res[z];
          res[z]++;
```

## 例题

 你现在很想知道⼀一个数列A[1…N]是啥，但是需要花费代价去获取情报，你可以花费 Cost[L][R]的值去得到A[L…R]的和，给定Cost，求最少花费多少代价才能确定 A[1…N]
 $1\le N \le 1000,Cost[L][R] \le 10^9$
 
 
 **solution**
 
 只要知道所有点的前缀和，就可以知道原数列。给出的$[L,R]$的和之后，只要知道$S[L]$或$S[R]$就可以推出来另一个。所以将这些条件转化为边。然后建立最小生成树。
 
## 例题2

给定每个点的度数d[i],求有几个满足的无根树。

**solution**

再prufer序列中，每个点会被扔进去$d[i] - 1$次，所以无根树的个数为$\prod\limits_{i=1}^n(d[i]-1)!$

## 判环

>判断一个图是否有偶环

**solution**

先求出生成树，枚举非树边，如果连出偶环，结束。如果有两个奇环有相交的边。那么就有偶环

## hall定理

### 定理内容

>一个二分图存在完美匹配的充要条件是，(设$|v1|\le|v2|$),对于左侧点集$v1$中的任意$k(1 \le k\le n)$个点，在右侧点集$v2$中都有至少k个点与之相邻.

### 应用

>给定一个 [n,n] 个点的二分图，每条边有边权，要求删去边权和最小的边集，使得这张图没有完美匹配

**solution**



## 边的染色

给定一张无向图，边有边权且为0或1，有些边的边权还没有确定，现在需要你确定这些边的边权，使得满足所有环的边权的异或值都为0，求方案数

**solution**

一种边权对应了$2^k$种点权，k为联通块个数。

最终答案为$2^{s-k}$,s为已确定的边构成的联通块个数。k为全部边构成的联通块个数。

## 选择

给定 n 个数对 (x[i],y[i])，你需要构造一个数组 s[i]，满足 s[i] 是 x[i] 和 y[i] 中的其中一个，且 s 里没有重复元素，顺便数个方案数

**solution**

对于每个点值建一个点。然后对于每个x[i],y[i]。将其值进行连边。然后给每条边赋值。如果边数大于点数，无解。如果点数=边数。则是一个基环树。给每棵树上的边赋为他下面的点的值，环上的就可以两个方向连。方案数为2(环的两个方向)。如果点数=边数+1.则是一棵树，方案数为n(选不同的根)

## 练习题

有一个 N\*M 的矩形，其中有K个格子中有病毒，现在你可以进行若干次消毒，每次你可以选择一个任意大小的子矩形进行消毒，假设是A*B的矩形，则代价是 min(A,B)，要 求你⽤用最少的代价进行消毒

**solution**

本质上只有两种操作，给某一行消毒或给某一列消毒。对于一个病毒$(x,y)$要么第$x$行被消毒。要么第$y$列被消毒。所以从x向y连一条边。构成二分图。求最小点覆盖。
